<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline';">
    <title>PolÃ­gono Vocal Remover</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <header class="header">
        <div class="header__logo">
            <img src="../assets/logo.png" alt="PolÃ­gono Studio" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
            <span style="display:none; font-size: 24px;">ðŸŽµ</span>
        </div>
        <div class="header__content">
            <div class="header__title">PolÃ­gono Vocal Remover</div>
            <div class="header__subtitle">AI-Powered Audio Separation Â· Batch Processing</div>
        </div>
    </header>

    <main class="main">
        <!-- Control Panel -->
        <aside class="panel-control">
            <!-- Add Files Section -->
            <div class="section">
                <div class="section__title">Add Files</div>
                <div id="drop-zone" class="drop-zone">
                    <div class="drop-zone__icon">
                        <i class="fas fa-file-audio"></i>
                    </div>
                    <div class="drop-zone__text">Drop Audio or Video Files</div>
                    <div class="drop-zone__hint">Or click to browse (supports multiple files)</div>
                </div>
            </div>

            <!-- Global Settings Section -->
            <div class="section">
                <div class="section__title">Global Settings</div>

                <div class="form-group">
                    <label class="form-label">Processing Mode</label>
                    <select id="opt-mode" class="form-select">
                        <option value="vocal_remover">Vocal Remover (2 Tracks)</option>
                        <option value="splitter">Stem Splitter (4 Tracks)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label class="form-label">Device</label>
                    <select id="opt-device" class="form-select">
                        <option value="auto">Auto-detect</option>
                        <option value="cuda">GPU (CUDA)</option>
                        <option value="cpu">CPU Only</option>
                    </select>
                </div>

                <div class="form-group">
                    <label class="form-label">Output Format</label>
                    <select id="opt-format" class="form-select">
                        <option value="wav">WAV (Lossless)</option>
                        <option value="flac">FLAC (Compressed Lossless)</option>
                        <option value="mp3">MP3 (Lossy)</option>
                    </select>
                </div>

                <!-- Advanced Settings -->
                <div class="collapsible">
                    <button class="collapsible__trigger" id="advanced-toggle">
                        <span class="collapsible__icon">â–¶</span>
                        <span>Advanced Settings</span>
                    </button>

                    <div class="collapsible__content" id="advanced-settings">
                        <div class="form-group">
                            <label class="form-label">AI Model</label>
                            <select id="opt-model" class="form-select">
                                <option value="htdemucs_ft">Demucs v4 Fine-tuned (Best)</option>
                                <option value="htdemucs">Demucs v4 Standard</option>
                                <option value="mdx_extra">MDX-Net Extra (Fast)</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Quality</label>
                            <select id="opt-quality" class="form-select">
                                <option value="fast">Fast (1 shift)</option>
                                <option value="hq" selected>High Quality (2 shifts)</option>
                                <option value="ultra">Ultra (5 shifts)</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Queue Actions Section -->
            <div class="section">
                <div class="section__title">Queue Actions</div>

                <button id="btn-start-queue" class="btn btn-primary" disabled>
                    <i class="fas fa-play"></i> Start Queue
                </button>

                <div class="btn-group mt-sm">
                    <button id="btn-stop-queue" class="btn btn-secondary" disabled>
                        <i class="fas fa-stop"></i> Stop
                    </button>

                    <button id="btn-clear-completed" class="btn btn-secondary">
                        <i class="fas fa-trash"></i> Clear
                    </button>
                </div>
            </div>
        </aside>

        <!-- Queue Panel -->
        <section class="panel-queue">
            <div class="queue-header">
                <div>
                    <div class="queue-header__title">Job Queue</div>
                    <div class="queue-stats" id="queue-stats">
                        0 pending Â· 0 processing Â· 0 completed
                    </div>
                </div>
            </div>

            <div id="job-list" class="job-list">
                <!-- Job items will be inserted here dynamically -->
            </div>

            <!-- Console Log -->
            <div class="console-section">
                <div class="console-toggle" id="console-toggle">
                    <span class="console-toggle__text">Debug Log</span>
                    <span>â–¼</span>
                </div>
                <div id="console-log" class="console-log">
                    <!-- Log entries will be inserted here -->
                </div>
            </div>
        </section>
    </main>

    <script>
        const { ipcRenderer } = require('electron');
        const path = require('path');

        // =================================================================
        // State Management
        // =================================================================

        const state = {
            queue: [], // Array of job objects
            isProcessing: false,
            currentJobId: null,
            nextJobId: 1,
        };

        // Job states: 'pending', 'processing', 'completed', 'error'
        function createJob(fileInfo) {
            return {
                id: state.nextJobId++,
                file: fileInfo,
                status: 'pending',
                progress: 0,
                detail: 'Waiting...',
                error: null,
                outputPath: null,
            };
        }

        // =================================================================
        // DOM Elements
        // =================================================================

        const elements = {
            dropZone: document.getElementById('drop-zone'),
            jobList: document.getElementById('job-list'),
            queueStats: document.getElementById('queue-stats'),
            btnStartQueue: document.getElementById('btn-start-queue'),
            btnStopQueue: document.getElementById('btn-stop-queue'),
            btnClearCompleted: document.getElementById('btn-clear-completed'),
            optMode: document.getElementById('opt-mode'),
            optDevice: document.getElementById('opt-device'),
            optFormat: document.getElementById('opt-format'),
            optModel: document.getElementById('opt-model'),
            optQuality: document.getElementById('opt-quality'),
            advancedToggle: document.getElementById('advanced-toggle'),
            advancedSettings: document.getElementById('advanced-settings'),
            consoleToggle: document.getElementById('console-toggle'),
            consoleLog: document.getElementById('console-log'),
        };

        // =================================================================
        // UI Helpers
        // =================================================================

        function updateQueueStats() {
            const pending = state.queue.filter(j => j.status === 'pending').length;
            const processing = state.queue.filter(j => j.status === 'processing').length;
            const completed = state.queue.filter(j => j.status === 'completed').length;

            elements.queueStats.textContent =
                `${pending} pending Â· ${processing} processing Â· ${completed} completed`;

            // Update button states
            const hasPending = pending > 0 || processing > 0;
            elements.btnStartQueue.disabled = state.isProcessing || state.queue.length === 0;
            elements.btnStopQueue.disabled = !state.isProcessing;
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return `${bytes} B`;
            if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
            return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
        }

        function getStatusIcon(status) {
            switch (status) {
                case 'pending': return 'â³';
                case 'processing': return 'âš™ï¸';
                case 'completed': return 'âœ…';
                case 'error': return 'âŒ';
                default: return 'â—';
            }
        }

        function logConsole(message, level = 'info') {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            const time = new Date().toLocaleTimeString();
            entry.innerHTML = `<span class="log-level">[${level}]</span> ${time} - ${message}`;
            elements.consoleLog.appendChild(entry);
            elements.consoleLog.scrollTop = elements.consoleLog.scrollHeight;
        }

        // =================================================================
        // Job Rendering
        // =================================================================

        function renderJob(job) {
            const existingItem = document.getElementById(`job-${job.id}`);

            const jobHtml = `
                <div class="job-status">
                    ${getStatusIcon(job.status)}
                </div>
                <div class="job-info">
                    <div class="job-name" title="${job.file.name}">${job.file.name}</div>
                    <div class="job-meta">
                        ${job.file.type.toUpperCase()} Â· ${formatFileSize(job.file.size)} Â· .${job.file.extension}
                    </div>
                    <div class="job-progress">
                        <div class="job-progress-bar" style="width: ${job.progress}%"></div>
                    </div>
                    <div class="job-detail">${job.detail}</div>
                </div>
                <div class="job-actions">
                    ${job.status === 'completed' ?
                        `<button class="job-btn open" title="Open folder" data-job-id="${job.id}" data-action="open">ðŸ“‚</button>` :
                        ''}
                    ${job.status === 'pending' || job.status === 'error' || job.status === 'completed' ?
                        `<button class="job-btn remove" title="Remove" data-job-id="${job.id}" data-action="remove">âœ•</button>` :
                        ''}
                </div>
            `;

            if (existingItem) {
                existingItem.className = `job-item ${job.status}`;
                existingItem.innerHTML = jobHtml;
            } else {
                const item = document.createElement('div');
                item.id = `job-${job.id}`;
                item.className = `job-item ${job.status}`;
                item.innerHTML = jobHtml;
                elements.jobList.appendChild(item);
            }
        }

        function renderAllJobs() {
            elements.jobList.innerHTML = '';
            state.queue.forEach(job => renderJob(job));
            updateQueueStats();
        }

        function updateJob(jobId, updates) {
            const job = state.queue.find(j => j.id === jobId);
            if (job) {
                Object.assign(job, updates);
                renderJob(job);
                updateQueueStats();
            }
        }

        // =================================================================
        // File Handling
        // =================================================================

        async function addFiles(filePaths) {
            if (!Array.isArray(filePaths) || filePaths.length === 0) {
                logConsole('No files to add', 'error');
                return;
            }

            logConsole(`Adding ${filePaths.length} file(s) to queue...`);

            for (const filePath of filePaths) {
                const info = await ipcRenderer.invoke('file:getInfo', filePath);

                if (info.valid) {
                    const job = createJob(info);
                    state.queue.push(job);
                    renderJob(job);
                    logConsole(`Added: ${info.name}`);
                } else {
                    logConsole(`Invalid file: ${path.basename(filePath)} - ${info.reason}`, 'error');
                }
            }

            updateQueueStats();
        }

        // Drop Zone - Click to browse
        elements.dropZone.addEventListener('click', async () => {
            const filePaths = await ipcRenderer.invoke('dialog:openFile');
            if (filePaths) {
                // dialog:openFile now always returns an array
                await addFiles(filePaths);
            }
        });

        // Drop Zone - Drag and drop
        elements.dropZone.addEventListener('dragenter', (e) => {
            e.preventDefault();
            e.stopPropagation();
        });

        elements.dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            elements.dropZone.classList.add('drag-over');
        });

        elements.dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            elements.dropZone.classList.remove('drag-over');
        });

        elements.dropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            elements.dropZone.classList.remove('drag-over');

            // Drag & Drop is temporarily disabled due to Electron limitations
            // Use the Browse button instead for multiple file selection
            logConsole('Drag & Drop is not currently supported', 'warn');
            logConsole('Please use the "Browse" button to select multiple files', 'info');
        });

        // =================================================================
        // Queue Processing
        // =================================================================

        async function processQueue() {
            if (state.isProcessing) return;

            state.isProcessing = true;
            updateQueueStats();
            logConsole('Queue processing started');

            while (true) {
                // Find next pending job
                const job = state.queue.find(j => j.status === 'pending');

                if (!job) {
                    // No more pending jobs
                    break;
                }

                // Process this job
                state.currentJobId = job.id;
                updateJob(job.id, {
                    status: 'processing',
                    detail: 'Initializing...',
                    progress: 0
                });

                logConsole(`Processing: ${job.file.name}`);

                try {
                    // Get global settings
                    const options = {
                        mode: elements.optMode.value,
                        model: elements.optModel.value,
                        quality: elements.optQuality.value,
                        device: elements.optDevice.value,
                        outputFormat: elements.optFormat.value,
                    };

                    // Start motor
                    const result = await ipcRenderer.invoke('motor:start', {
                        inputPath: job.file.path,
                        outputDir: null, // Use same directory as input
                        options
                    });

                    if (!result.success) {
                        throw new Error(result.error || 'Unknown error');
                    }

                    // Wait for completion (motor events will update progress)
                    // The motor will send 'motor:success' or 'motor:error' event
                    // which will be handled by event listeners below

                    // Wait for job to finish (status changes from 'processing')
                    await new Promise((resolve) => {
                        const checkInterval = setInterval(() => {
                            const currentJob = state.queue.find(j => j.id === job.id);
                            if (currentJob && currentJob.status !== 'processing') {
                                clearInterval(checkInterval);
                                resolve();
                            }
                        }, 500);
                    });

                } catch (error) {
                    logConsole(`Error processing ${job.file.name}: ${error.message}`, 'error');
                    updateJob(job.id, {
                        status: 'error',
                        detail: `Error: ${error.message}`,
                        error: error.message,
                    });
                }

                state.currentJobId = null;

                // Check if we should stop (user clicked stop button)
                if (!state.isProcessing) {
                    break;
                }

                // CRITICAL: Wait 1 second before starting next job to prevent race condition
                // This gives the main process time to cleanup properly
                logConsole('Waiting 1s before next job...');
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            state.isProcessing = false;
            updateQueueStats();
            logConsole('Queue processing finished');
        }

        // Start Queue
        elements.btnStartQueue.addEventListener('click', () => {
            processQueue();
        });

        // Stop Queue
        elements.btnStopQueue.addEventListener('click', async () => {
            logConsole('Stopping queue...');
            state.isProcessing = false;

            // Cancel current job
            if (state.currentJobId) {
                await ipcRenderer.invoke('motor:cancel');
            }

            updateQueueStats();
        });

        // Clear Completed Jobs
        elements.btnClearCompleted.addEventListener('click', () => {
            const before = state.queue.length;
            state.queue = state.queue.filter(j => j.status !== 'completed');
            const removed = before - state.queue.length;

            if (removed > 0) {
                logConsole(`Removed ${removed} completed job(s)`);
                renderAllJobs();
            }
        });

        // =================================================================
        // Job Actions (Remove, Open Folder)
        // =================================================================

        elements.jobList.addEventListener('click', async (e) => {
            const button = e.target.closest('.job-btn');
            if (!button) return;

            const jobId = parseInt(button.dataset.jobId);
            const action = button.dataset.action;
            const job = state.queue.find(j => j.id === jobId);

            if (!job) return;

            if (action === 'remove') {
                const index = state.queue.indexOf(job);
                state.queue.splice(index, 1);
                logConsole(`Removed job: ${job.file.name}`);
                renderAllJobs();
            } else if (action === 'open' && job.outputPath) {
                await ipcRenderer.invoke('shell:openPath', job.outputPath);
            }
        });

        // =================================================================
        // Motor Event Listeners
        // =================================================================

        ipcRenderer.on('motor:start', (event, data) => {
            if (state.currentJobId) {
                logConsole(`Motor started for job ${state.currentJobId}: ${data.model} on ${data.device}`);
            }
        });

        ipcRenderer.on('motor:step', (event, data) => {
            if (state.currentJobId) {
                updateJob(state.currentJobId, {
                    detail: `Step ${data.stepNumber}/${data.totalSteps}: ${data.step}`,
                });
            }
        });

        ipcRenderer.on('motor:progress', (event, data) => {
            if (state.currentJobId) {
                const progress = data.stepPercent || data.globalPercent || 0;
                updateJob(state.currentJobId, {
                    progress: Math.round(progress),
                    detail: data.detail || `Processing: ${Math.round(progress)}%`,
                });
            }
        });

        ipcRenderer.on('motor:log', (event, data) => {
            logConsole(data.message, data.level || 'info');
        });

        ipcRenderer.on('motor:warning', (event, data) => {
            logConsole(`âš ï¸ ${data.message}`, 'warn');
        });

        ipcRenderer.on('motor:error', (event, data) => {
            logConsole(`Error: ${data.message}`, 'error');

            if (data.fatal && state.currentJobId) {
                updateJob(state.currentJobId, {
                    status: 'error',
                    detail: `Error: ${data.message}`,
                    error: data.message,
                });
            }
        });

        ipcRenderer.on('motor:success', (event, data) => {
            if (state.currentJobId) {
                logConsole(`Job ${state.currentJobId} completed successfully`);

                // Get output path from first output file
                let outputPath = null;
                if (data.outputs) {
                    const firstOutput = Object.values(data.outputs)[0];
                    if (firstOutput) {
                        outputPath = path.dirname(firstOutput);
                    }
                }

                updateJob(state.currentJobId, {
                    status: 'completed',
                    progress: 100,
                    detail: `âœ… Completed in ${data.elapsedSeconds?.toFixed(1)}s`,
                    outputPath: outputPath,
                });
            }
        });

        ipcRenderer.on('motor:cancelled', (event, data) => {
            if (state.currentJobId) {
                logConsole(`Job ${state.currentJobId} cancelled`);
                updateJob(state.currentJobId, {
                    status: 'error',
                    detail: 'Cancelled by user',
                    error: 'Cancelled',
                });
            }
        });

        // =================================================================
        // Advanced Settings Toggle
        // =================================================================

        elements.advancedToggle.addEventListener('click', () => {
            const icon = elements.advancedToggle.querySelector('.collapsible__icon');
            const isOpen = elements.advancedSettings.classList.toggle('open');
            icon.classList.toggle('open', isOpen);
        });

        // =================================================================
        // Console Toggle
        // =================================================================

        elements.consoleToggle.addEventListener('click', () => {
            const isOpen = elements.consoleLog.classList.toggle('open');
            const arrow = elements.consoleToggle.querySelector('span:last-child');
            if (arrow) {
                arrow.textContent = isOpen ? 'â–²' : 'â–¼';
            }
        });

        // =================================================================
        // Prevent default drag & drop behavior on entire window
        // =================================================================

        // Prevent browser from opening dropped files outside the drop zone
        document.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        document.addEventListener('drop', (e) => {
            e.preventDefault();
        });

        // =================================================================
        // Initialization
        // =================================================================

        logConsole('Queue system initialized');
        updateQueueStats();
    </script>
</body>
</html>
