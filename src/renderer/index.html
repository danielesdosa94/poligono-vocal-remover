<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline';">
    <title>Pol√≠gono AI Hub</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- i18n Translations -->
    <script src="js/translations.js"></script>
</head>
<body>
    <div class="app-container">
        <!-- Header - Solo Navegaci√≥n -->
        <header class="header">
            <nav class="header__nav">
                <button class="nav-tab active" data-i18n="tab_vocal_remover">Vocal Remover</button>
                <button class="nav-tab" data-i18n="tab_stem_splitter">Stem Splitter</button>
                <button class="nav-tab" data-i18n="tab_settings">Settings</button>
            </nav>
        </header>

        <!-- Brand - Logo y T√≠tulo -->
        <section class="brand">
            <div class="brand__content">
                <img
                    src="../assets/logo.png"
                    alt="Pol√≠gono AI"
                    class="brand__logo"
                    onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                <span class="brand__logo-fallback">üéµ</span>
                <h1 class="brand__title" data-i18n="app_title">AI AUDIO HUB</h1>
            </div>
            <div class="brand__subtitle" id="mode-description" data-i18n="mode_vocal_remover_subtitle">
                Extract Vocals & Instrumental (2 Tracks)
            </div>
        </section>

        <!-- Spacer Forzado -->
        <div class="spacer-lg"></div>

        <!-- Main Content - Two Column Grid -->
        <main class="main">
            <!-- Control Panel - Left Column (320px) -->
            <aside class="panel-control">
                <!-- Drop Zone -->
                <div class="control-section">
                    <div class="section__title" data-i18n="panel_add_files">Add Files</div>
                    <div id="drop-zone" class="drop-zone">
                        <div class="drop-zone__icon">
                            <i class="fas fa-file-audio"></i>
                        </div>
                        <div class="drop-zone__text" data-i18n="dropzone_text">Drop Files Here</div>
                        <div class="drop-zone__hint" data-i18n="dropzone_hint">or click to browse</div>
                    </div>
                </div>

                <!-- Simple Settings (Only Output Format) -->
                <div class="control-section control-section--scrollable">
                    <div class="section__title" data-i18n="panel_output_settings">Output Settings</div>

                    <div class="form-group">
                        <label class="form-label" data-i18n="settings_output_format">Output Format</label>
                        <select id="opt-format" class="form-select">
                            <option value="wav" data-i18n="format_wav">WAV (Lossless)</option>
                            <option value="flac" data-i18n="format_flac">FLAC</option>
                            <option value="mp3" data-i18n="format_mp3">MP3</option>
                        </select>
                    </div>

                    <!-- Hidden controls for advanced settings -->
                    <select id="opt-model" class="form-select hidden">
                        <option value="htdemucs_ft" selected>Demucs v4 FT (Best)</option>
                        <option value="htdemucs">Demucs v4 Standard</option>
                        <option value="mdx_extra">MDX-Net (Fast)</option>
                    </select>

                    <select id="opt-device" class="form-select hidden">
                        <option value="auto" selected>Auto-detect</option>
                        <option value="cuda">GPU (CUDA)</option>
                        <option value="cpu">CPU Only</option>
                    </select>

                    <select id="opt-quality" class="form-select hidden">
                        <option value="fast">Fast (1 shift)</option>
                        <option value="hq" selected>High (2 shifts)</option>
                        <option value="ultra">Ultra (5 shifts)</option>
                    </select>

                    <select id="opt-mode" class="form-select hidden">
                        <option value="vocal_remover" selected>Vocal Remover</option>
                        <option value="splitter">Stem Splitter</option>
                    </select>
                </div>

                <!-- Action Buttons (Anclados al fondo) -->
                <div class="control-section control-section--actions">
                    <button id="btn-start-queue" class="btn btn-primary" disabled>
                        <i class="fas fa-play"></i> <span data-i18n="button_start_queue">Start Queue</span>
                    </button>

                    <div class="btn-group">
                        <button id="btn-stop-queue" class="btn btn-secondary" disabled>
                            <i class="fas fa-stop"></i> <span data-i18n="button_stop">Stop</span>
                        </button>
                        <button id="btn-clear-completed" class="btn btn-secondary">
                            <i class="fas fa-trash"></i> <span data-i18n="button_clear">Clear</span>
                        </button>
                    </div>
                </div>
            </aside>

            <!-- Right Area - Multi-View Container -->
            <div style="flex: 1; display: flex; flex-direction: column; overflow: hidden;">
                <!-- View 1 & 2: Queue Panel (Vocal Remover & Stem Splitter) -->
                <section id="view-queue" class="panel-queue view active">
                    <!-- Queue Header -->
                    <div class="queue-header">
                        <div class="queue-header__title" data-i18n="queue_title">Job Queue</div>
                        <div class="queue-stats" id="queue-stats">
                            <span>0 pending ¬∑ 0 processing ¬∑ 0 completed</span>
                        </div>
                    </div>

                    <!-- Job List - Scroll Interno -->
                    <div id="job-list" class="job-list">
                        <!-- Job items will be inserted here dynamically -->
                    </div>

                    <!-- Debug Log - Details Colapsado -->
                    <details class="console-details" id="console-details">
                        <summary data-i18n="debug_log_title">Debug Log</summary>
                        <div id="console-log" class="console-log">
                            <!-- Log entries will be inserted here -->
                        </div>
                    </details>
                </section>

                <!-- View 3: Settings Panel -->
                <section id="view-settings" class="settings-panel view">
                    <div class="settings-panel__title">
                        <i class="fas fa-cog"></i> <span data-i18n="settings_title">Advanced Settings</span>
                    </div>
                    <div class="settings-panel__subtitle" data-i18n="settings_subtitle">
                        Configure AI models, processing quality, and hardware preferences
                    </div>

                    <div class="settings-grid">
                        <!-- Language Card -->
                        <div class="settings-card">
                            <div class="settings-card__title">
                                <i class="fas fa-globe"></i> <span data-i18n="settings_language_title">Language / Idioma</span>
                            </div>
                            <div class="form-group">
                                <label class="form-label" data-i18n="settings_language_label">Select Language</label>
                                <select id="settings-language" class="form-select">
                                    <option value="en" data-i18n="settings_language_option_en">üá∫üá∏ English</option>
                                    <option value="es" data-i18n="settings_language_option_es">üá™üá∏ Espa√±ol</option>
                                </select>
                            </div>
                            <p style="font-size: 12px; color: var(--color-text-muted); margin-top: 8px;" data-i18n="settings_language_description">
                                Choose your preferred language for the interface.
                            </p>
                        </div>

                        <!-- AI Model Card -->
                        <div class="settings-card">
                            <div class="settings-card__title">
                                <i class="fas fa-brain"></i> <span data-i18n="settings_ai_model_title">AI Model</span>
                            </div>
                            <div class="form-group">
                                <label class="form-label" data-i18n="settings_ai_model_label">Select Model</label>
                                <select id="settings-model" class="form-select">
                                    <option value="htdemucs_ft" data-i18n="settings_ai_model_option_ft">Demucs v4 Fine-tuned (Best Quality)</option>
                                    <option value="htdemucs" data-i18n="settings_ai_model_option_standard">Demucs v4 Standard</option>
                                    <option value="mdx_extra" data-i18n="settings_ai_model_option_mdx">MDX-Net Extra (Faster)</option>
                                </select>
                            </div>
                            <p style="font-size: 12px; color: var(--color-text-muted); margin-top: 8px;" data-i18n="settings_ai_model_description">
                                Fine-tuned model provides the best quality but requires more processing time.
                            </p>
                        </div>

                        <!-- Quality Card -->
                        <div class="settings-card">
                            <div class="settings-card__title">
                                <i class="fas fa-sliders-h"></i> <span data-i18n="settings_quality_title">Processing Quality</span>
                            </div>
                            <div class="form-group">
                                <label class="form-label" data-i18n="settings_quality_label">Quality Level</label>
                                <select id="settings-quality" class="form-select">
                                    <option value="fast" data-i18n="settings_quality_option_fast">Fast (1 shift)</option>
                                    <option value="hq" selected data-i18n="settings_quality_option_hq">High Quality (2 shifts)</option>
                                    <option value="ultra" data-i18n="settings_quality_option_ultra">Ultra Quality (5 shifts)</option>
                                </select>
                            </div>
                            <p style="font-size: 12px; color: var(--color-text-muted); margin-top: 8px;" data-i18n="settings_quality_description">
                                Higher quality uses multiple processing passes for better separation.
                            </p>
                        </div>

                        <!-- Device Card -->
                        <div class="settings-card">
                            <div class="settings-card__title">
                                <i class="fas fa-microchip"></i> <span data-i18n="settings_device_title">Hardware Device</span>
                            </div>
                            <div class="form-group">
                                <label class="form-label" data-i18n="settings_device_label">Processing Device</label>
                                <select id="settings-device" class="form-select">
                                    <option value="auto" data-i18n="settings_device_option_auto">Auto-detect (Recommended)</option>
                                    <option value="cuda" data-i18n="settings_device_option_cuda">GPU (CUDA)</option>
                                    <option value="cpu" data-i18n="settings_device_option_cpu">CPU Only</option>
                                </select>
                            </div>
                            <p style="font-size: 12px; color: var(--color-text-muted); margin-top: 8px;" data-i18n="settings_device_description">
                                GPU acceleration (CUDA) is significantly faster if available.
                            </p>
                        </div>
                    </div>
                </section>
            </div>
        </main>
    </div>

    <script>
        const { ipcRenderer, webUtils } = require('electron');
        const path = require('path');

        // =================================================================
        // State Management
        // =================================================================

        const state = {
            queue: [], // Array of job objects
            isProcessing: false,
            currentJobId: null,
            nextJobId: 1,
        };

        // Job states: 'pending', 'processing', 'completed', 'error'
        function createJob(fileInfo) {
            // If queue is running, new files enter as 'Waiting...'
            // If queue is stopped, they enter as 'Ready'
            const dict = translations[currentLanguage] || translations['en'];
            const detail = state.isProcessing ? dict.job_waiting : dict.job_ready;

            return {
                id: state.nextJobId++,
                file: fileInfo,
                status: 'pending',
                progress: 0,
                detail: detail,
                error: null,
                outputPath: null,
            };
        }

        // =================================================================
        // DOM Elements
        // =================================================================

        const elements = {
            dropZone: document.getElementById('drop-zone'),
            jobList: document.getElementById('job-list'),
            queueStats: document.getElementById('queue-stats'),
            btnStartQueue: document.getElementById('btn-start-queue'),
            btnStopQueue: document.getElementById('btn-stop-queue'),
            btnClearCompleted: document.getElementById('btn-clear-completed'),
            optMode: document.getElementById('opt-mode'),
            optDevice: document.getElementById('opt-device'),
            optFormat: document.getElementById('opt-format'),
            optModel: document.getElementById('opt-model'),
            optQuality: document.getElementById('opt-quality'),
            consoleLog: document.getElementById('console-log'),
            navTabs: document.querySelectorAll('.nav-tab'),
            // Views
            viewQueue: document.getElementById('view-queue'),
            viewSettings: document.getElementById('view-settings'),
            // Settings panel controls
            settingsModel: document.getElementById('settings-model'),
            settingsQuality: document.getElementById('settings-quality'),
            settingsDevice: document.getElementById('settings-device'),
            settingsLanguage: document.getElementById('settings-language'),
            // Brand subtitle
            modeDescription: document.getElementById('mode-description'),
        };

        // Current mode state
        let currentMode = 'vocal_remover';

        // =================================================================
        // UI Helpers
        // =================================================================

        function updateQueueStats() {
            const pending = state.queue.filter(j => j.status === 'pending').length;
            const processing = state.queue.filter(j => j.status === 'processing').length;
            const completed = state.queue.filter(j => j.status === 'completed').length;

            const dict = translations[currentLanguage] || translations['en'];
            elements.queueStats.textContent = interpolate(dict.queue_stats, {
                pending,
                processing,
                completed
            });

            // Update button states
            const hasPending = pending > 0 || processing > 0;
            elements.btnStartQueue.disabled = state.isProcessing || state.queue.length === 0;
            elements.btnStopQueue.disabled = !state.isProcessing;
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return `${bytes} B`;
            if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
            return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
        }

        function getStatusIcon(status, detail) {
            switch (status) {
                case 'pending':
                    // Show circle for 'Ready', hourglass for 'Waiting...'
                    return detail === 'Ready' ? '‚óã' : '‚è≥';
                case 'processing': return '‚öôÔ∏è';
                case 'completed': return '‚úÖ';
                case 'error': return '‚ùå';
                default: return '‚óè';
            }
        }

        function logConsole(message, level = 'info') {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            const time = new Date().toLocaleTimeString();
            entry.innerHTML = `<span class="log-level">[${level}]</span> ${time} - ${message}`;
            elements.consoleLog.appendChild(entry);
            elements.consoleLog.scrollTop = elements.consoleLog.scrollHeight;
        }

        // =================================================================
        // Job Rendering
        // =================================================================

        function renderJob(job) {
            const existingItem = document.getElementById(`job-${job.id}`);

            const jobHtml = `
                <div class="job-status">
                    ${getStatusIcon(job.status, job.detail)}
                </div>
                <div class="job-info">
                    <div class="job-name" title="${job.file.name}">${job.file.name}</div>
                    <div class="job-meta">
                        ${job.file.type.toUpperCase()} ¬∑ ${formatFileSize(job.file.size)} ¬∑ .${job.file.extension}
                    </div>
                    <div class="job-progress">
                        <div class="job-progress-bar" style="width: ${job.progress}%"></div>
                    </div>
                    <div class="job-detail">${job.detail}</div>
                </div>
                <div class="job-actions">
                    ${job.status === 'completed' ?
                        `<button class="job-btn open" title="Open folder" data-job-id="${job.id}" data-action="open">üìÇ</button>` :
                        ''}
                    ${job.status === 'pending' || job.status === 'error' || job.status === 'completed' ?
                        `<button class="job-btn remove" title="Remove" data-job-id="${job.id}" data-action="remove">‚úï</button>` :
                        ''}
                </div>
            `;

            if (existingItem) {
                existingItem.className = `job-item ${job.status}`;
                existingItem.innerHTML = jobHtml;
            } else {
                const item = document.createElement('div');
                item.id = `job-${job.id}`;
                item.className = `job-item ${job.status}`;
                item.innerHTML = jobHtml;
                elements.jobList.appendChild(item);
            }
        }

        function renderAllJobs() {
            elements.jobList.innerHTML = '';
            state.queue.forEach(job => renderJob(job));
            updateQueueStats();
        }

        function updateJob(jobId, updates) {
            const job = state.queue.find(j => j.id === jobId);
            if (job) {
                Object.assign(job, updates);
                renderJob(job);
                updateQueueStats();
            }
        }

        // =================================================================
        // File Handling
        // =================================================================

        async function addFiles(filePaths) {
            if (!Array.isArray(filePaths) || filePaths.length === 0) {
                logConsole('No files to add', 'error');
                return;
            }

            logConsole(`Adding ${filePaths.length} file(s) to queue...`);

            for (const filePath of filePaths) {
                const info = await ipcRenderer.invoke('file:getInfo', filePath);

                if (info.valid) {
                    const job = createJob(info);
                    state.queue.push(job);
                    renderJob(job);
                    logConsole(`Added: ${info.name}`);
                } else {
                    logConsole(`Invalid file: ${path.basename(filePath)} - ${info.reason}`, 'error');
                }
            }

            updateQueueStats();
        }

        // Drop Zone - Click to browse
        elements.dropZone.addEventListener('click', async () => {
            const filePaths = await ipcRenderer.invoke('dialog:openFile');
            if (filePaths) {
                // dialog:openFile now always returns an array
                await addFiles(filePaths);
            }
        });

        // Drop Zone - Drag and drop (ROBUST VERSION WITH LOGGING)
        const dropZone = document.getElementById('drop-zone');

        dropZone.addEventListener('dragenter', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('üéØ Drag Enter detected');
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('üîÑ Hovering over drop zone...');
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            // Only remove if leaving the dropZone itself, not child elements
            if (e.target === dropZone) {
                console.log('üö™ Drag Leave detected');
                dropZone.classList.remove('drag-over');
            }
        });

        dropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('üí• DROP DETECTED!');

            dropZone.classList.remove('drag-over');

            const files = e.dataTransfer.files;
            console.log('üì¶ Files dropped:', files.length);

            if (!files || files.length === 0) {
                console.warn('‚ö†Ô∏è No files in dataTransfer');
                return;
            }

            const filePaths = [];
            for (let i = 0; i < files.length; i++) {
                const file = files[i];

                // Use webUtils.getPathForFile() for modern Electron versions
                const filePath = webUtils.getPathForFile(file);

                console.log(`üìÑ File ${i + 1}:`, {
                    name: file.name,
                    path: filePath,
                    type: file.type,
                    size: file.size
                });

                if (filePath) {
                    filePaths.push(filePath);
                } else {
                    console.error(`‚ùå File ${i + 1} has no valid path!`);
                }
            }

            console.log('üöÄ Sending paths to addFiles:', filePaths);

            if (filePaths.length > 0) {
                await addFiles(filePaths);
            } else {
                console.error('‚ùå No valid file paths extracted');
            }
        });

        // =================================================================
        // Queue Processing
        // =================================================================

        async function processQueue() {
            if (state.isProcessing) return;

            state.isProcessing = true;
            updateQueueStats();
            logConsole('Queue processing started');

            while (true) {
                // Find next pending job
                const job = state.queue.find(j => j.status === 'pending');

                if (!job) {
                    // No more pending jobs
                    break;
                }

                // Process this job
                state.currentJobId = job.id;
                updateJob(job.id, {
                    status: 'processing',
                    detail: 'Initializing...',
                    progress: 0
                });

                logConsole(`Processing: ${job.file.name}`);

                try {
                    // Get global settings
                    const options = {
                        mode: elements.optMode.value,
                        model: elements.optModel.value,
                        quality: elements.optQuality.value,
                        device: elements.optDevice.value,
                        outputFormat: elements.optFormat.value,
                    };

                    // Start motor
                    const result = await ipcRenderer.invoke('motor:start', {
                        inputPath: job.file.path,
                        outputDir: null, // Use same directory as input
                        options
                    });

                    if (!result.success) {
                        throw new Error(result.error || 'Unknown error');
                    }

                    // Wait for completion (motor events will update progress)
                    // The motor will send 'motor:success' or 'motor:error' event
                    // which will be handled by event listeners below

                    // Wait for job to finish (status changes from 'processing')
                    await new Promise((resolve) => {
                        const checkInterval = setInterval(() => {
                            const currentJob = state.queue.find(j => j.id === job.id);
                            if (currentJob && currentJob.status !== 'processing') {
                                clearInterval(checkInterval);
                                resolve();
                            }
                        }, 500);
                    });

                } catch (error) {
                    logConsole(`Error processing ${job.file.name}: ${error.message}`, 'error');
                    updateJob(job.id, {
                        status: 'error',
                        detail: `Error: ${error.message}`,
                        error: error.message,
                    });
                }

                state.currentJobId = null;

                // Check if we should stop (user clicked stop button)
                if (!state.isProcessing) {
                    break;
                }

                // CRITICAL: Wait 1 second before starting next job to prevent race condition
                // This gives the main process time to cleanup properly
                logConsole('Waiting 1s before next job...');
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            state.isProcessing = false;
            updateQueueStats();
            logConsole('Queue processing finished');
        }

        // Start Queue
        elements.btnStartQueue.addEventListener('click', () => {
            const dict = translations[currentLanguage] || translations['en'];

            // Change all pending jobs from 'Ready' to 'Waiting...'
            state.queue.forEach(job => {
                if (job.status === 'pending' && (job.detail === dict.job_ready || job.detail === translations.en.job_ready || job.detail === translations.es.job_ready)) {
                    job.detail = dict.job_waiting;
                    renderJob(job);
                }
            });

            processQueue();
        });

        // Stop Queue
        elements.btnStopQueue.addEventListener('click', async () => {
            const dict = translations[currentLanguage] || translations['en'];
            logConsole(dict.console_stopping_queue);
            state.isProcessing = false;

            // Cancel current job
            if (state.currentJobId) {
                await ipcRenderer.invoke('motor:cancel');
            }

            // Change all pending jobs from 'Waiting...' back to 'Ready'
            state.queue.forEach(job => {
                if (job.status === 'pending' && (job.detail === dict.job_waiting || job.detail === translations.en.job_waiting || job.detail === translations.es.job_waiting)) {
                    job.detail = dict.job_ready;
                    renderJob(job);
                }
            });

            updateQueueStats();
        });

        // Clear Completed Jobs
        elements.btnClearCompleted.addEventListener('click', () => {
            const before = state.queue.length;
            state.queue = state.queue.filter(j => j.status !== 'completed');
            const removed = before - state.queue.length;

            if (removed > 0) {
                logConsole(`Removed ${removed} completed job(s)`);
                renderAllJobs();
            }
        });

        // =================================================================
        // Job Actions (Remove, Open Folder)
        // =================================================================

        elements.jobList.addEventListener('click', async (e) => {
            const button = e.target.closest('.job-btn');
            if (!button) return;

            const jobId = parseInt(button.dataset.jobId);
            const action = button.dataset.action;
            const job = state.queue.find(j => j.id === jobId);

            if (!job) return;

            if (action === 'remove') {
                const index = state.queue.indexOf(job);
                state.queue.splice(index, 1);
                logConsole(`Removed job: ${job.file.name}`);
                renderAllJobs();
            } else if (action === 'open' && job.outputPath) {
                await ipcRenderer.invoke('shell:openPath', job.outputPath);
            }
        });

        // =================================================================
        // Motor Event Listeners
        // =================================================================

        ipcRenderer.on('motor:start', (event, data) => {
            if (state.currentJobId) {
                logConsole(`Motor started for job ${state.currentJobId}: ${data.model} on ${data.device}`);
            }
        });

        ipcRenderer.on('motor:step', (event, data) => {
            if (state.currentJobId) {
                updateJob(state.currentJobId, {
                    detail: `Step ${data.stepNumber}/${data.totalSteps}: ${data.step}`,
                });
            }
        });

        ipcRenderer.on('motor:progress', (event, data) => {
            if (state.currentJobId) {
                const rawProgress = data.stepPercent || data.globalPercent || 0;
                // Scale to 90% (AI processing phase)
                const scaledProgress = Math.round(rawProgress * 0.9);

                const dict = translations[currentLanguage] || translations['en'];
                updateJob(state.currentJobId, {
                    progress: scaledProgress,
                    detail: interpolate(dict.job_processing_ai, { progress: scaledProgress }),
                });
            }
        });

        ipcRenderer.on('motor:log', (event, data) => {
            logConsole(data.message, data.level || 'info');
        });

        ipcRenderer.on('motor:warning', (event, data) => {
            logConsole(`‚ö†Ô∏è ${data.message}`, 'warn');
        });

        ipcRenderer.on('motor:error', (event, data) => {
            logConsole(`Error: ${data.message}`, 'error');

            if (data.fatal && state.currentJobId) {
                updateJob(state.currentJobId, {
                    status: 'error',
                    detail: `Error: ${data.message}`,
                    error: data.message,
                });
            }
        });

        ipcRenderer.on('motor:success', (event, data) => {
            if (state.currentJobId) {
                const dict = translations[currentLanguage] || translations['en'];
                logConsole(interpolate(dict.console_job_completed, { id: state.currentJobId }));

                // Get output path from first output file
                let outputPath = null;
                if (data.outputs) {
                    const firstOutput = Object.values(data.outputs)[0];
                    if (firstOutput) {
                        outputPath = path.dirname(firstOutput);
                    }
                }

                // Force progress to 100% when files are saved
                updateJob(state.currentJobId, {
                    status: 'completed',
                    progress: 100,
                    detail: `‚úÖ ${interpolate(dict.job_completed, { time: data.elapsedSeconds?.toFixed(1) })}`,
                    outputPath: outputPath,
                });
            }
        });

        ipcRenderer.on('motor:cancelled', (event, data) => {
            if (state.currentJobId) {
                logConsole(`Job ${state.currentJobId} cancelled`);
                updateJob(state.currentJobId, {
                    status: 'error',
                    detail: 'Cancelled by user',
                    error: 'Cancelled',
                });
            }
        });

        // =================================================================
        // Navigation Tabs - View Switcher
        // =================================================================

        elements.navTabs.forEach((tab, index) => {
            tab.addEventListener('click', () => {
                const dict = translations[currentLanguage] || translations['en'];

                // Remove active from all tabs
                elements.navTabs.forEach(t => t.classList.remove('active'));

                // Add active to clicked tab
                tab.classList.add('active');

                // Switch view and mode based on tab
                if (index === 0) {
                    // Vocal Remover - Show Queue View
                    currentMode = 'vocal_remover';
                    showView('queue');
                    elements.optMode.value = 'vocal_remover';
                    elements.modeDescription.textContent = dict.mode_vocal_remover_subtitle;
                    elements.modeDescription.setAttribute('data-i18n', 'mode_vocal_remover_subtitle');
                    logConsole(dict.console_mode_switched_vocal);
                } else if (index === 1) {
                    // Stem Splitter - Show Queue View
                    currentMode = 'splitter';
                    showView('queue');
                    elements.optMode.value = 'splitter';
                    elements.modeDescription.textContent = dict.mode_splitter_subtitle;
                    elements.modeDescription.setAttribute('data-i18n', 'mode_splitter_subtitle');
                    logConsole(dict.console_mode_switched_splitter);
                } else if (index === 2) {
                    // Settings - Show Settings View
                    showView('settings');
                    elements.modeDescription.textContent = dict.mode_settings_subtitle;
                    elements.modeDescription.setAttribute('data-i18n', 'mode_settings_subtitle');
                    logConsole(dict.console_settings_opened);
                }
            });
        });

        // =================================================================
        // View Management
        // =================================================================

        function showView(viewName) {
            // Hide all views
            elements.viewQueue.classList.remove('active');
            elements.viewSettings.classList.remove('active');

            // Show selected view
            if (viewName === 'queue') {
                elements.viewQueue.classList.add('active');
            } else if (viewName === 'settings') {
                elements.viewSettings.classList.add('active');
            }
        }

        // =================================================================
        // Settings Synchronization
        // =================================================================

        // Sync settings panel controls with hidden controls
        elements.settingsModel.addEventListener('change', () => {
            elements.optModel.value = elements.settingsModel.value;
            logConsole(`AI Model changed to: ${elements.settingsModel.value}`);
        });

        elements.settingsQuality.addEventListener('change', () => {
            elements.optQuality.value = elements.settingsQuality.value;
            logConsole(`Quality changed to: ${elements.settingsQuality.value}`);
        });

        elements.settingsDevice.addEventListener('change', () => {
            elements.optDevice.value = elements.settingsDevice.value;
            logConsole(`Device changed to: ${elements.settingsDevice.value}`);
        });

        // Initialize settings panel with current values
        elements.settingsModel.value = elements.optModel.value;
        elements.settingsQuality.value = elements.optQuality.value;
        elements.settingsDevice.value = elements.optDevice.value;

        // =================================================================
        // Internationalization (i18n)
        // =================================================================

        // Current language state
        let currentLanguage = localStorage.getItem('language') || 'en';

        // Update all UI text based on selected language
        function updateLanguage(lang) {
            if (!translations[lang]) {
                console.error(`Language '${lang}' not found in translations`);
                return;
            }

            currentLanguage = lang;
            const dict = translations[lang];

            // Update all elements with data-i18n attribute
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (dict[key]) {
                    element.textContent = dict[key];
                }
            });

            // Update queue stats manually (has dynamic content)
            updateQueueStats();

            // Update mode subtitle based on current mode
            if (currentMode === 'vocal_remover') {
                elements.modeDescription.textContent = dict.mode_vocal_remover_subtitle;
            } else if (currentMode === 'splitter') {
                elements.modeDescription.textContent = dict.mode_splitter_subtitle;
            }

            // Update job details for pending jobs (Ready/Waiting)
            state.queue.forEach(job => {
                if (job.status === 'pending') {
                    if (job.detail === 'Ready' || job.detail === 'Listo') {
                        job.detail = dict.job_ready;
                    } else if (job.detail === 'Waiting...' || job.detail === 'Esperando...') {
                        job.detail = dict.job_waiting;
                    }
                    renderJob(job);
                }
            });

            // Save preference to localStorage
            localStorage.setItem('language', lang);

            // Log language change
            logConsole(interpolate(dict.console_language_changed, { value: lang }));
        }

        // Language selector event listener
        elements.settingsLanguage.addEventListener('change', () => {
            updateLanguage(elements.settingsLanguage.value);
        });

        // Initialize language selector with saved preference
        elements.settingsLanguage.value = currentLanguage;

        // =================================================================
        // Prevent default drag & drop behavior on entire window
        // =================================================================

        // CRITICAL: Prevent browser from opening dropped files outside the drop zone
        document.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
        }, false);

        document.addEventListener('drop', (e) => {
            // Only prevent default if NOT dropping on the drop zone
            // The drop zone handler will handle its own preventDefault
            if (!e.target.closest('#drop-zone')) {
                e.preventDefault();
                e.stopPropagation();
                console.log('üö´ Dropped outside drop zone - prevented default behavior');
            }
        }, false);

        // Additional safety: prevent dragenter on document
        document.addEventListener('dragenter', (e) => {
            e.preventDefault();
        }, false);

        // =================================================================
        // Initialization
        // =================================================================

        // Apply saved language on startup
        updateLanguage(currentLanguage);

        const dict = translations[currentLanguage] || translations['en'];
        logConsole(dict.console_queue_initialized);
        updateQueueStats();
    </script>
</body>
</html>
