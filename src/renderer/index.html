<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline';">
    <title>PolÃ­gono AI Hub</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="app-container">
        <!-- Header - Solo NavegaciÃ³n -->
        <header class="header">
            <nav class="header__nav">
                <button class="nav-tab active" data-i18n="tab.vocal_remover">Vocal Remover</button>
                <button class="nav-tab" data-i18n="tab.stem_splitter">Stem Splitter</button>
                <button class="nav-tab" data-i18n="tab.settings">Settings</button>
            </nav>
        </header>

        <!-- Brand - Logo y TÃ­tulo -->
        <section class="brand">
            <div class="brand__content">
                <img
                    src="../assets/logo.png"
                    alt="PolÃ­gono AI"
                    class="brand__logo"
                    onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                <span class="brand__logo-fallback">ðŸŽµ</span>
                <h1 class="brand__title" data-i18n="app.title">AI AUDIO HUB</h1>
            </div>
            <div class="brand__subtitle" id="mode-description" data-i18n="mode.vocal_remover.subtitle">
                Extract Vocals & Instrumental (2 Tracks)
            </div>
        </section>

        <!-- Spacer Forzado -->
        <div class="spacer-lg"></div>

        <!-- Main Content - Two Column Grid -->
        <main class="main">
            <!-- Control Panel - Left Column (320px) -->
            <aside class="panel-control">
                <!-- Drop Zone -->
                <div class="control-section">
                    <div class="section__title" data-i18n="panel.add_files">Add Files</div>
                    <div id="drop-zone" class="drop-zone">
                        <div class="drop-zone__icon">
                            <i class="fas fa-file-audio"></i>
                        </div>
                        <div class="drop-zone__text" data-i18n="dropzone.text">Drop Files Here</div>
                        <div class="drop-zone__hint" data-i18n="dropzone.hint">or click to browse</div>
                    </div>
                </div>

                <!-- Simple Settings (Only Output Format) -->
                <div class="control-section control-section--scrollable">
                    <div class="section__title" data-i18n="panel.output_settings">Output Settings</div>

                    <div class="form-group">
                        <label class="form-label" data-i18n="settings.output_format">Output Format</label>
                        <select id="opt-format" class="form-select">
                            <option value="wav" data-i18n="format.wav">WAV (Lossless)</option>
                            <option value="flac" data-i18n="format.flac">FLAC</option>
                            <option value="mp3" data-i18n="format.mp3">MP3</option>
                        </select>
                    </div>

                    <!-- Hidden controls for advanced settings -->
                    <select id="opt-model" class="form-select hidden">
                        <option value="htdemucs_ft" selected>Demucs v4 FT (Best)</option>
                        <option value="htdemucs">Demucs v4 Standard</option>
                        <option value="mdx_extra">MDX-Net (Fast)</option>
                    </select>

                    <select id="opt-device" class="form-select hidden">
                        <option value="auto" selected>Auto-detect</option>
                        <option value="cuda">GPU (CUDA)</option>
                        <option value="cpu">CPU Only</option>
                    </select>

                    <select id="opt-quality" class="form-select hidden">
                        <option value="fast">Fast (1 shift)</option>
                        <option value="hq" selected>High (2 shifts)</option>
                        <option value="ultra">Ultra (5 shifts)</option>
                    </select>

                    <select id="opt-mode" class="form-select hidden">
                        <option value="vocal_remover" selected>Vocal Remover</option>
                        <option value="splitter">Stem Splitter</option>
                    </select>
                </div>

                <!-- Action Buttons (Anclados al fondo) -->
                <div class="control-section control-section--actions">
                    <button id="btn-start-queue" class="btn btn-primary" disabled data-i18n="button.start_queue">
                        <i class="fas fa-play"></i> <span>Start Queue</span>
                    </button>

                    <div class="btn-group">
                        <button id="btn-stop-queue" class="btn btn-secondary" disabled data-i18n="button.stop">
                            <i class="fas fa-stop"></i> <span>Stop</span>
                        </button>
                        <button id="btn-clear-completed" class="btn btn-secondary" data-i18n="button.clear">
                            <i class="fas fa-trash"></i> <span>Clear</span>
                        </button>
                    </div>
                </div>
            </aside>

            <!-- Right Area - Multi-View Container -->
            <div style="flex: 1; display: flex; flex-direction: column; overflow: hidden;">
                <!-- View 1 & 2: Queue Panel (Vocal Remover & Stem Splitter) -->
                <section id="view-queue" class="panel-queue view active">
                    <!-- Queue Header -->
                    <div class="queue-header">
                        <div class="queue-header__title" data-i18n="queue.title">Job Queue</div>
                        <div class="queue-stats" id="queue-stats">
                            <span data-i18n-template="queue.stats">0 pending Â· 0 processing Â· 0 completed</span>
                        </div>
                    </div>

                    <!-- Job List - Scroll Interno -->
                    <div id="job-list" class="job-list">
                        <!-- Job items will be inserted here dynamically -->
                    </div>

                    <!-- Debug Log - Details Colapsado -->
                    <details class="console-details" id="console-details">
                        <summary>Debug Log</summary>
                        <div id="console-log" class="console-log">
                            <!-- Log entries will be inserted here -->
                        </div>
                    </details>
                </section>

                <!-- View 3: Settings Panel -->
                <section id="view-settings" class="settings-panel view">
                    <div class="settings-panel__title">
                        <i class="fas fa-cog"></i> Advanced Settings
                    </div>
                    <div class="settings-panel__subtitle">
                        Configure AI models, processing quality, and hardware preferences
                    </div>

                    <div class="settings-grid">
                        <!-- AI Model Card -->
                        <div class="settings-card">
                            <div class="settings-card__title">
                                <i class="fas fa-brain"></i> AI Model
                            </div>
                            <div class="form-group">
                                <label class="form-label">Select Model</label>
                                <select id="settings-model" class="form-select">
                                    <option value="htdemucs_ft">Demucs v4 Fine-tuned (Best Quality)</option>
                                    <option value="htdemucs">Demucs v4 Standard</option>
                                    <option value="mdx_extra">MDX-Net Extra (Faster)</option>
                                </select>
                            </div>
                            <p style="font-size: 12px; color: var(--color-text-muted); margin-top: 8px;">
                                Fine-tuned model provides the best quality but requires more processing time.
                            </p>
                        </div>

                        <!-- Quality Card -->
                        <div class="settings-card">
                            <div class="settings-card__title">
                                <i class="fas fa-sliders-h"></i> Processing Quality
                            </div>
                            <div class="form-group">
                                <label class="form-label">Quality Level</label>
                                <select id="settings-quality" class="form-select">
                                    <option value="fast">Fast (1 shift)</option>
                                    <option value="hq" selected>High Quality (2 shifts)</option>
                                    <option value="ultra">Ultra Quality (5 shifts)</option>
                                </select>
                            </div>
                            <p style="font-size: 12px; color: var(--color-text-muted); margin-top: 8px;">
                                Higher quality uses multiple processing passes for better separation.
                            </p>
                        </div>

                        <!-- Device Card -->
                        <div class="settings-card">
                            <div class="settings-card__title">
                                <i class="fas fa-microchip"></i> Hardware Device
                            </div>
                            <div class="form-group">
                                <label class="form-label">Processing Device</label>
                                <select id="settings-device" class="form-select">
                                    <option value="auto">Auto-detect (Recommended)</option>
                                    <option value="cuda">GPU (CUDA)</option>
                                    <option value="cpu">CPU Only</option>
                                </select>
                            </div>
                            <p style="font-size: 12px; color: var(--color-text-muted); margin-top: 8px;">
                                GPU acceleration (CUDA) is significantly faster if available.
                            </p>
                        </div>
                    </div>
                </section>
            </div>
        </main>
    </div>

    <script>
        const { ipcRenderer } = require('electron');
        const path = require('path');

        // =================================================================
        // State Management
        // =================================================================

        const state = {
            queue: [], // Array of job objects
            isProcessing: false,
            currentJobId: null,
            nextJobId: 1,
        };

        // Job states: 'pending', 'processing', 'completed', 'error'
        function createJob(fileInfo) {
            return {
                id: state.nextJobId++,
                file: fileInfo,
                status: 'pending',
                progress: 0,
                detail: 'Waiting...',
                error: null,
                outputPath: null,
            };
        }

        // =================================================================
        // DOM Elements
        // =================================================================

        const elements = {
            dropZone: document.getElementById('drop-zone'),
            jobList: document.getElementById('job-list'),
            queueStats: document.getElementById('queue-stats'),
            btnStartQueue: document.getElementById('btn-start-queue'),
            btnStopQueue: document.getElementById('btn-stop-queue'),
            btnClearCompleted: document.getElementById('btn-clear-completed'),
            optMode: document.getElementById('opt-mode'),
            optDevice: document.getElementById('opt-device'),
            optFormat: document.getElementById('opt-format'),
            optModel: document.getElementById('opt-model'),
            optQuality: document.getElementById('opt-quality'),
            consoleLog: document.getElementById('console-log'),
            navTabs: document.querySelectorAll('.nav-tab'),
            // Views
            viewQueue: document.getElementById('view-queue'),
            viewSettings: document.getElementById('view-settings'),
            // Settings panel controls
            settingsModel: document.getElementById('settings-model'),
            settingsQuality: document.getElementById('settings-quality'),
            settingsDevice: document.getElementById('settings-device'),
            // Brand subtitle
            modeDescription: document.getElementById('mode-description'),
        };

        // Current mode state
        let currentMode = 'vocal_remover';

        // =================================================================
        // UI Helpers
        // =================================================================

        function updateQueueStats() {
            const pending = state.queue.filter(j => j.status === 'pending').length;
            const processing = state.queue.filter(j => j.status === 'processing').length;
            const completed = state.queue.filter(j => j.status === 'completed').length;

            elements.queueStats.textContent =
                `${pending} pending Â· ${processing} processing Â· ${completed} completed`;

            // Update button states
            const hasPending = pending > 0 || processing > 0;
            elements.btnStartQueue.disabled = state.isProcessing || state.queue.length === 0;
            elements.btnStopQueue.disabled = !state.isProcessing;
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return `${bytes} B`;
            if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
            return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
        }

        function getStatusIcon(status) {
            switch (status) {
                case 'pending': return 'â³';
                case 'processing': return 'âš™ï¸';
                case 'completed': return 'âœ…';
                case 'error': return 'âŒ';
                default: return 'â—';
            }
        }

        function logConsole(message, level = 'info') {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            const time = new Date().toLocaleTimeString();
            entry.innerHTML = `<span class="log-level">[${level}]</span> ${time} - ${message}`;
            elements.consoleLog.appendChild(entry);
            elements.consoleLog.scrollTop = elements.consoleLog.scrollHeight;
        }

        // =================================================================
        // Job Rendering
        // =================================================================

        function renderJob(job) {
            const existingItem = document.getElementById(`job-${job.id}`);

            const jobHtml = `
                <div class="job-status">
                    ${getStatusIcon(job.status)}
                </div>
                <div class="job-info">
                    <div class="job-name" title="${job.file.name}">${job.file.name}</div>
                    <div class="job-meta">
                        ${job.file.type.toUpperCase()} Â· ${formatFileSize(job.file.size)} Â· .${job.file.extension}
                    </div>
                    <div class="job-progress">
                        <div class="job-progress-bar" style="width: ${job.progress}%"></div>
                    </div>
                    <div class="job-detail">${job.detail}</div>
                </div>
                <div class="job-actions">
                    ${job.status === 'completed' ?
                        `<button class="job-btn open" title="Open folder" data-job-id="${job.id}" data-action="open">ðŸ“‚</button>` :
                        ''}
                    ${job.status === 'pending' || job.status === 'error' || job.status === 'completed' ?
                        `<button class="job-btn remove" title="Remove" data-job-id="${job.id}" data-action="remove">âœ•</button>` :
                        ''}
                </div>
            `;

            if (existingItem) {
                existingItem.className = `job-item ${job.status}`;
                existingItem.innerHTML = jobHtml;
            } else {
                const item = document.createElement('div');
                item.id = `job-${job.id}`;
                item.className = `job-item ${job.status}`;
                item.innerHTML = jobHtml;
                elements.jobList.appendChild(item);
            }
        }

        function renderAllJobs() {
            elements.jobList.innerHTML = '';
            state.queue.forEach(job => renderJob(job));
            updateQueueStats();
        }

        function updateJob(jobId, updates) {
            const job = state.queue.find(j => j.id === jobId);
            if (job) {
                Object.assign(job, updates);
                renderJob(job);
                updateQueueStats();
            }
        }

        // =================================================================
        // File Handling
        // =================================================================

        async function addFiles(filePaths) {
            if (!Array.isArray(filePaths) || filePaths.length === 0) {
                logConsole('No files to add', 'error');
                return;
            }

            logConsole(`Adding ${filePaths.length} file(s) to queue...`);

            for (const filePath of filePaths) {
                const info = await ipcRenderer.invoke('file:getInfo', filePath);

                if (info.valid) {
                    const job = createJob(info);
                    state.queue.push(job);
                    renderJob(job);
                    logConsole(`Added: ${info.name}`);
                } else {
                    logConsole(`Invalid file: ${path.basename(filePath)} - ${info.reason}`, 'error');
                }
            }

            updateQueueStats();
        }

        // Drop Zone - Click to browse
        elements.dropZone.addEventListener('click', async () => {
            const filePaths = await ipcRenderer.invoke('dialog:openFile');
            if (filePaths) {
                // dialog:openFile now always returns an array
                await addFiles(filePaths);
            }
        });

        // Drop Zone - Drag and drop
        elements.dropZone.addEventListener('dragenter', (e) => {
            e.preventDefault();
            e.stopPropagation();
        });

        elements.dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            elements.dropZone.classList.add('drag-over');
        });

        elements.dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            elements.dropZone.classList.remove('drag-over');
        });

        elements.dropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            elements.dropZone.classList.remove('drag-over');

            // Drag & Drop is temporarily disabled due to Electron limitations
            // Use the Browse button instead for multiple file selection
            logConsole('Drag & Drop is not currently supported', 'warn');
            logConsole('Please use the "Browse" button to select multiple files', 'info');
        });

        // =================================================================
        // Queue Processing
        // =================================================================

        async function processQueue() {
            if (state.isProcessing) return;

            state.isProcessing = true;
            updateQueueStats();
            logConsole('Queue processing started');

            while (true) {
                // Find next pending job
                const job = state.queue.find(j => j.status === 'pending');

                if (!job) {
                    // No more pending jobs
                    break;
                }

                // Process this job
                state.currentJobId = job.id;
                updateJob(job.id, {
                    status: 'processing',
                    detail: 'Initializing...',
                    progress: 0
                });

                logConsole(`Processing: ${job.file.name}`);

                try {
                    // Get global settings
                    const options = {
                        mode: elements.optMode.value,
                        model: elements.optModel.value,
                        quality: elements.optQuality.value,
                        device: elements.optDevice.value,
                        outputFormat: elements.optFormat.value,
                    };

                    // Start motor
                    const result = await ipcRenderer.invoke('motor:start', {
                        inputPath: job.file.path,
                        outputDir: null, // Use same directory as input
                        options
                    });

                    if (!result.success) {
                        throw new Error(result.error || 'Unknown error');
                    }

                    // Wait for completion (motor events will update progress)
                    // The motor will send 'motor:success' or 'motor:error' event
                    // which will be handled by event listeners below

                    // Wait for job to finish (status changes from 'processing')
                    await new Promise((resolve) => {
                        const checkInterval = setInterval(() => {
                            const currentJob = state.queue.find(j => j.id === job.id);
                            if (currentJob && currentJob.status !== 'processing') {
                                clearInterval(checkInterval);
                                resolve();
                            }
                        }, 500);
                    });

                } catch (error) {
                    logConsole(`Error processing ${job.file.name}: ${error.message}`, 'error');
                    updateJob(job.id, {
                        status: 'error',
                        detail: `Error: ${error.message}`,
                        error: error.message,
                    });
                }

                state.currentJobId = null;

                // Check if we should stop (user clicked stop button)
                if (!state.isProcessing) {
                    break;
                }

                // CRITICAL: Wait 1 second before starting next job to prevent race condition
                // This gives the main process time to cleanup properly
                logConsole('Waiting 1s before next job...');
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            state.isProcessing = false;
            updateQueueStats();
            logConsole('Queue processing finished');
        }

        // Start Queue
        elements.btnStartQueue.addEventListener('click', () => {
            processQueue();
        });

        // Stop Queue
        elements.btnStopQueue.addEventListener('click', async () => {
            logConsole('Stopping queue...');
            state.isProcessing = false;

            // Cancel current job
            if (state.currentJobId) {
                await ipcRenderer.invoke('motor:cancel');
            }

            updateQueueStats();
        });

        // Clear Completed Jobs
        elements.btnClearCompleted.addEventListener('click', () => {
            const before = state.queue.length;
            state.queue = state.queue.filter(j => j.status !== 'completed');
            const removed = before - state.queue.length;

            if (removed > 0) {
                logConsole(`Removed ${removed} completed job(s)`);
                renderAllJobs();
            }
        });

        // =================================================================
        // Job Actions (Remove, Open Folder)
        // =================================================================

        elements.jobList.addEventListener('click', async (e) => {
            const button = e.target.closest('.job-btn');
            if (!button) return;

            const jobId = parseInt(button.dataset.jobId);
            const action = button.dataset.action;
            const job = state.queue.find(j => j.id === jobId);

            if (!job) return;

            if (action === 'remove') {
                const index = state.queue.indexOf(job);
                state.queue.splice(index, 1);
                logConsole(`Removed job: ${job.file.name}`);
                renderAllJobs();
            } else if (action === 'open' && job.outputPath) {
                await ipcRenderer.invoke('shell:openPath', job.outputPath);
            }
        });

        // =================================================================
        // Motor Event Listeners
        // =================================================================

        ipcRenderer.on('motor:start', (event, data) => {
            if (state.currentJobId) {
                logConsole(`Motor started for job ${state.currentJobId}: ${data.model} on ${data.device}`);
            }
        });

        ipcRenderer.on('motor:step', (event, data) => {
            if (state.currentJobId) {
                updateJob(state.currentJobId, {
                    detail: `Step ${data.stepNumber}/${data.totalSteps}: ${data.step}`,
                });
            }
        });

        ipcRenderer.on('motor:progress', (event, data) => {
            if (state.currentJobId) {
                const progress = data.stepPercent || data.globalPercent || 0;
                updateJob(state.currentJobId, {
                    progress: Math.round(progress),
                    detail: data.detail || `Processing: ${Math.round(progress)}%`,
                });
            }
        });

        ipcRenderer.on('motor:log', (event, data) => {
            logConsole(data.message, data.level || 'info');
        });

        ipcRenderer.on('motor:warning', (event, data) => {
            logConsole(`âš ï¸ ${data.message}`, 'warn');
        });

        ipcRenderer.on('motor:error', (event, data) => {
            logConsole(`Error: ${data.message}`, 'error');

            if (data.fatal && state.currentJobId) {
                updateJob(state.currentJobId, {
                    status: 'error',
                    detail: `Error: ${data.message}`,
                    error: data.message,
                });
            }
        });

        ipcRenderer.on('motor:success', (event, data) => {
            if (state.currentJobId) {
                logConsole(`Job ${state.currentJobId} completed successfully`);

                // Get output path from first output file
                let outputPath = null;
                if (data.outputs) {
                    const firstOutput = Object.values(data.outputs)[0];
                    if (firstOutput) {
                        outputPath = path.dirname(firstOutput);
                    }
                }

                updateJob(state.currentJobId, {
                    status: 'completed',
                    progress: 100,
                    detail: `âœ… Completed in ${data.elapsedSeconds?.toFixed(1)}s`,
                    outputPath: outputPath,
                });
            }
        });

        ipcRenderer.on('motor:cancelled', (event, data) => {
            if (state.currentJobId) {
                logConsole(`Job ${state.currentJobId} cancelled`);
                updateJob(state.currentJobId, {
                    status: 'error',
                    detail: 'Cancelled by user',
                    error: 'Cancelled',
                });
            }
        });

        // =================================================================
        // Navigation Tabs - View Switcher
        // =================================================================

        elements.navTabs.forEach((tab, index) => {
            tab.addEventListener('click', () => {
                // Remove active from all tabs
                elements.navTabs.forEach(t => t.classList.remove('active'));

                // Add active to clicked tab
                tab.classList.add('active');

                // Switch view and mode based on tab
                if (index === 0) {
                    // Vocal Remover - Show Queue View
                    currentMode = 'vocal_remover';
                    showView('queue');
                    elements.optMode.value = 'vocal_remover';
                    elements.modeDescription.textContent = 'Extract Vocals & Instrumental (2 Tracks)';
                    elements.modeDescription.setAttribute('data-i18n', 'mode.vocal_remover.subtitle');
                    logConsole('Switched to Vocal Remover mode');
                } else if (index === 1) {
                    // Stem Splitter - Show Queue View
                    currentMode = 'splitter';
                    showView('queue');
                    elements.optMode.value = 'splitter';
                    elements.modeDescription.textContent = 'Separate into 4 Stems (Vocals, Bass, Drums, Other)';
                    elements.modeDescription.setAttribute('data-i18n', 'mode.splitter.subtitle');
                    logConsole('Switched to Stem Splitter mode');
                } else if (index === 2) {
                    // Settings - Show Settings View
                    showView('settings');
                    elements.modeDescription.textContent = 'Configure AI models, processing quality, and hardware';
                    elements.modeDescription.setAttribute('data-i18n', 'mode.settings.subtitle');
                    logConsole('Opened Settings panel');
                }
            });
        });

        // =================================================================
        // View Management
        // =================================================================

        function showView(viewName) {
            // Hide all views
            elements.viewQueue.classList.remove('active');
            elements.viewSettings.classList.remove('active');

            // Show selected view
            if (viewName === 'queue') {
                elements.viewQueue.classList.add('active');
            } else if (viewName === 'settings') {
                elements.viewSettings.classList.add('active');
            }
        }

        // =================================================================
        // Settings Synchronization
        // =================================================================

        // Sync settings panel controls with hidden controls
        elements.settingsModel.addEventListener('change', () => {
            elements.optModel.value = elements.settingsModel.value;
            logConsole(`AI Model changed to: ${elements.settingsModel.value}`);
        });

        elements.settingsQuality.addEventListener('change', () => {
            elements.optQuality.value = elements.settingsQuality.value;
            logConsole(`Quality changed to: ${elements.settingsQuality.value}`);
        });

        elements.settingsDevice.addEventListener('change', () => {
            elements.optDevice.value = elements.settingsDevice.value;
            logConsole(`Device changed to: ${elements.settingsDevice.value}`);
        });

        // Initialize settings panel with current values
        elements.settingsModel.value = elements.optModel.value;
        elements.settingsQuality.value = elements.optQuality.value;
        elements.settingsDevice.value = elements.optDevice.value;

        // =================================================================
        // Prevent default drag & drop behavior on entire window
        // =================================================================

        // Prevent browser from opening dropped files outside the drop zone
        document.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        document.addEventListener('drop', (e) => {
            e.preventDefault();
        });

        // =================================================================
        // Initialization
        // =================================================================

        logConsole('Queue system initialized');
        updateQueueStats();
    </script>
</body>
</html>
